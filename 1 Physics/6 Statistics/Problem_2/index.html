<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<link href="../../../img/favicon.ico" rel="shortcut icon"/>
<title>Estimating π using Monte Carlo Methods - Physics and Mathematics</title>
<link href="../../../css/theme.css" rel="stylesheet"/>
<link href="../../../css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Estimating \u03c0 using Monte Carlo Methods";
        var mkdocs_page_input_path = "1 Physics/6 Statistics/Problem_2.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="../../../js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/rust.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="../../.."> Physics and Mathematics
        </a><div role="search">
<form action="../../../search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../..">Introduction</a>
</li>
</ul>
<p class="caption"><span class="caption-text">1 Physics</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal">1 Mechanics</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../1%20Mechanics/Problem_2/">Problem 2</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Gravity</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_1/">Problem 1</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_2/">Problem 2</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../2%20Gravity/Problem_3/">Problem 3</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Waves</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../3%20Waves/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Electromagnetism</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../4%20Electromagnetism/Problem_1/">Electromagnetism</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Circuits</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../5%20Circuits/Problem_1/">Problem 1</a>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal current">6 Statistics</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Problem_1/">Statistics</a>
</li>
<li class="toctree-l2 current"><a class="reference internal current" href="#">Estimating π using Monte Carlo Methods</a>
<ul class="current">
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#1-circle-method">1. Circle Method</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#implementation">Implementation</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#2-buffons-needle-method">2. Buffon's Needle Method</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#implementation_1">Implementation</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#3-comparison-of-methods">3. Comparison of Methods</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#circle-method">Circle Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#buffons-needle-method">Buffon's Needle Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#convergence-comparison">Convergence Comparison</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#4-mathematical-analysis">4. Mathematical Analysis</a>
<ul>
<li class="toctree-l4"><a class="reference internal" href="#circle-method_1">Circle Method</a>
</li>
<li class="toctree-l4"><a class="reference internal" href="#buffons-needle-method_1">Buffon's Needle Method</a>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#5-conclusion">5. Conclusion</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">7 Measurements</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../7%20Measurements/Problem_1/">Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum</a>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">2 Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/1%20Linear_algebra/">Linear Algebra</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/2%20Analytic_geometry/">Analytic geometry</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../2%20Mathematics/3%20Calculus/">Calculus</a>
</li>
</ul>
<p class="caption"><span class="caption-text">3 Discret Mathematics</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal">1 Set Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/">Set Theory</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/">Relations</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/">Functions</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">2 Number Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/">Combinatorics</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/">Number Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">3 Recurrence and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/">Sequences and Series</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/">Induction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/">Recurrence</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">4 Graph Theory and ...</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/">Graph Theory</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">5 Logic</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="../../../3%20Discret_Mathematics/5%20Logic/_01%20Logic/">Logic</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="../../..">Physics and Mathematics</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="../../.."></a></li>
<li class="breadcrumb-item">1 Physics</li>
<li class="breadcrumb-item">6 Statistics</li>
<li class="breadcrumb-item active">Estimating π using Monte Carlo Methods</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="estimating-using-monte-carlo-methods">Estimating π using Monte Carlo Methods</h1>
<h2 id="introduction">Introduction</h2>
<p>This problem explores two different Monte Carlo methods for estimating the mathematical constant π (pi): the circle method and Buffon's Needle method. Both approaches demonstrate how probabilistic techniques can be used to approximate deterministic mathematical constants.</p>
<h2 id="1-circle-method">1. Circle Method</h2>
<p>The circle method for estimating π is based on the ratio of the area of a circle to the area of its bounding square. For a circle of radius r inscribed in a square of side length 2r:</p>
<ul>
<li>Area of circle = πr²</li>
<li>Area of square = (2r)² = 4r²</li>
<li>Ratio = πr² / 4r² = π/4</li>
</ul>
<p>Therefore, π = 4 × (Area of circle / Area of square)</p>
<h3 id="implementation">Implementation</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import time

def estimate_pi_circle(n_points):
    """
    Estimate Pi using the circle method.

    Args:
        n_points: Number of random points to generate

    Returns:
        pi_estimate: Estimated value of Pi
        points_inside: Number of points inside the circle
        n_points: Total number of points
        execution_time: Time taken for the calculation
    """
    start_time = time.time()

    # Generate random points in the square [-1, 1] × [-1, 1]
    x = np.random.uniform(-1, 1, n_points)
    y = np.random.uniform(-1, 1, n_points)

    # Calculate distance from origin
    distance = np.sqrt(x**2 + y**2)

    # Count points inside the unit circle (radius 1)
    points_inside = np.sum(distance &lt;= 1)

    # Estimate Pi
    pi_estimate = 4 * points_inside / n_points

    execution_time = time.time() - start_time

    return pi_estimate, points_inside, n_points, execution_time

def plot_circle_monte_carlo(n_points, save_path=None):
    """
    Visualize the circle method for estimating Pi.

    Args:
        n_points: Number of random points to generate
        save_path: Path to save the figure (optional)
    """
    # Generate random points
    x = np.random.uniform(-1, 1, n_points)
    y = np.random.uniform(-1, 1, n_points)

    # Calculate distance from origin
    distance = np.sqrt(x**2 + y**2)

    # Separate points inside and outside the circle
    inside = distance &lt;= 1
    outside = ~inside

    # Create the plot
    plt.figure(figsize=(10, 10))

    # Plot the square
    plt.plot([-1, 1, 1, -1, -1], [-1, -1, 1, 1, -1], 'k-', linewidth=2)

    # Plot the circle
    theta = np.linspace(0, 2*np.pi, 100)
    plt.plot(np.cos(theta), np.sin(theta), 'k-', linewidth=2)

    # Plot the points
    plt.scatter(x[inside], y[inside], c='blue', s=10, alpha=0.6, label='Inside')
    plt.scatter(x[outside], y[outside], c='red', s=10, alpha=0.6, label='Outside')

    # Add labels and title
    plt.grid(True, alpha=0.3)
    plt.axis('equal')
    plt.title(f'Circle Method: {n_points} points')
    plt.xlabel('x')
    plt.ylabel('y')

    # Calculate and display the Pi estimate
    pi_estimate = 4 * np.sum(inside) / n_points
    plt.text(0.05, -0.95, f'π ≈ {pi_estimate:.6f}', fontsize=12, 
             bbox=dict(facecolor='white', alpha=0.8), transform=plt.gca().transAxes)

    plt.legend()

    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')

    plt.tight_layout()
    plt.show()

def convergence_analysis(max_points, step_size=1000, num_trials=5):
    """
    Analyze the convergence of the Pi estimation as the number of points increases.

    Args:
        max_points: Maximum number of points to use
        step_size: Step size for increasing the number of points
        num_trials: Number of trials for each point count

    Returns:
        point_counts: Array of point counts used
        pi_estimates: Array of Pi estimates
        execution_times: Array of execution times
    """
    point_counts = np.arange(step_size, max_points + step_size, step_size)
    pi_estimates = np.zeros((len(point_counts), num_trials))
    execution_times = np.zeros((len(point_counts), num_trials))

    for i, n in enumerate(point_counts):
        for j in range(num_trials):
            pi_est, _, _, exec_time = estimate_pi_circle(n)
            pi_estimates[i, j] = pi_est
            execution_times[i, j] = exec_time

    return point_counts, pi_estimates, execution_times

def plot_convergence(point_counts, pi_estimates, save_path=None):
    """
    Plot the convergence of Pi estimates as the number of points increases.

    Args:
        point_counts: Array of point counts used
        pi_estimates: Array of Pi estimates
        save_path: Path to save the figure (optional)
    """
    plt.figure(figsize=(12, 8))

    # Plot individual trials
    for j in range(pi_estimates.shape[1]):
        plt.plot(point_counts, pi_estimates[:, j], 'o-', alpha=0.3, markersize=3)

    # Plot mean estimate
    mean_estimate = np.mean(pi_estimates, axis=1)
    plt.plot(point_counts, mean_estimate, 'b-', linewidth=2, label='Mean Estimate')

    # Plot true value of Pi
    plt.axhline(y=np.pi, color='g', linestyle='--', label='True π')

    # Add error bands
    std_estimate = np.std(pi_estimates, axis=1)
    plt.fill_between(point_counts, 
                     mean_estimate - std_estimate, 
                     mean_estimate + std_estimate, 
                     color='b', alpha=0.2, label='±1 Standard Deviation')

    plt.xscale('log')
    plt.grid(True, alpha=0.3)
    plt.xlabel('Number of Points')
    plt.ylabel('Estimated π')
    plt.title('Convergence of Circle Method π Estimation')
    plt.legend()

    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    # Example usage
    n_points = 10000
    pi_estimate, points_inside, n_points, exec_time = estimate_pi_circle(n_points)
    print(f"Estimated π: {pi_estimate:.6f}")
    print(f"Points inside: {points_inside}/{n_points}")
    print(f"Execution time: {exec_time:.4f} seconds")

    # Visualize the method
    plot_circle_monte_carlo(1000, save_path="circle_monte_carlo.png")

    # Analyze convergence
    point_counts, pi_estimates, exec_times = convergence_analysis(100000, step_size=10000, num_trials=3)
    plot_convergence(point_counts, pi_estimates, save_path="circle_convergence.png")
</code></pre>
<p><img alt="Circle Method Visualization" src="../circle_monte_carlo.png"/></p>
<p><img alt="Circle Method Convergence" src="../circle_convergence.png"/></p>
<h2 id="2-buffons-needle-method">2. Buffon's Needle Method</h2>
<p>Buffon's Needle is a classic probability problem that can be used to estimate π. The method involves dropping a needle of length L onto a floor with parallel lines spaced a distance D apart. The probability that the needle crosses a line is related to π.</p>
<p>For a needle of length L and lines spaced a distance D apart, the probability P of the needle crossing a line is:</p>
<p>P = (2L) / (πD)</p>
<p>Therefore, π = (2L) / (PD)</p>
<h3 id="implementation_1">Implementation</h3>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import time

def estimate_pi_buffon(n_needles, needle_length=1.0, line_spacing=2.0):
    """
    Estimate Pi using Buffon's Needle method.

    Args:
        n_needles: Number of needles to drop
        needle_length: Length of the needle
        line_spacing: Distance between parallel lines

    Returns:
        pi_estimate: Estimated value of Pi
        crossings: Number of needle crossings
        n_needles: Total number of needles
        execution_time: Time taken for the calculation
    """
    start_time = time.time()

    # Generate random positions and angles for needles
    # y: distance from the center of the needle to the nearest line (0 to line_spacing/2)
    # theta: angle of the needle (0 to pi)
    y = np.random.uniform(0, line_spacing/2, n_needles)
    theta = np.random.uniform(0, np.pi, n_needles)

    # Calculate if needle crosses a line
    # A needle crosses a line if y &lt;= (needle_length/2) * sin(theta)
    crossings = np.sum(y &lt;= (needle_length/2) * np.sin(theta))

    # Estimate Pi using Buffon's formula: pi = (2 * needle_length * n_needles) / (line_spacing * crossings)
    pi_estimate = (2 * needle_length * n_needles) / (line_spacing * crossings)

    execution_time = time.time() - start_time

    return pi_estimate, crossings, n_needles, execution_time

def plot_buffon_needle(n_needles, needle_length=1.0, line_spacing=2.0, save_path=None):
    """
    Visualize Buffon's Needle method for estimating Pi.

    Args:
        n_needles: Number of needles to drop
        needle_length: Length of the needle
        line_spacing: Distance between parallel lines
        save_path: Path to save the figure (optional)
    """
    # Generate random positions and angles for needles
    x = np.random.uniform(0, 10, n_needles)  # x-position (arbitrary)
    y = np.random.uniform(0, line_spacing, n_needles)  # y-position
    theta = np.random.uniform(0, np.pi, n_needles)  # angle

    # Calculate if needle crosses a line
    crossings = y &lt;= (needle_length/2) * np.sin(theta)

    # Create the plot
    plt.figure(figsize=(12, 8))

    # Plot the parallel lines
    for i in range(0, 11, 2):
        plt.axhline(y=i*line_spacing, color='k', linestyle='-', alpha=0.5)

    # Plot the needles
    for i in range(n_needles):
        # Calculate endpoints of the needle
        dx = (needle_length/2) * np.cos(theta[i])
        dy = (needle_length/2) * np.sin(theta[i])

        # Plot the needle
        if crossings[i]:
            plt.plot([x[i]-dx, x[i]+dx], [y[i]-dy, y[i]+dy], 'r-', linewidth=1, alpha=0.7)
        else:
            plt.plot([x[i]-dx, x[i]+dx], [y[i]-dy, y[i]+dy], 'b-', linewidth=1, alpha=0.7)

    # Add labels and title
    plt.grid(True, alpha=0.3)
    plt.xlim(-1, 11)
    plt.ylim(-1, line_spacing*11)
    plt.title(f"Buffon's Needle: {n_needles} needles, {np.sum(crossings)} crossings")
    plt.xlabel("x")
    plt.ylabel("y")

    # Calculate and display the Pi estimate
    pi_estimate = (2 * needle_length * n_needles) / (line_spacing * np.sum(crossings))
    plt.text(0.05, -0.5, f'π ≈ {pi_estimate:.6f}', fontsize=12, 
             bbox=dict(facecolor='white', alpha=0.8), transform=plt.gca().transAxes)

    # Add legend
    plt.plot([], [], 'r-', label='Crossing')
    plt.plot([], [], 'b-', label='No Crossing')
    plt.legend()

    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')

    plt.tight_layout()
    plt.show()

def convergence_analysis(max_needles, step_size=1000, num_trials=5):
    """
    Analyze the convergence of the Pi estimation as the number of needles increases.

    Args:
        max_needles: Maximum number of needles to use
        step_size: Step size for increasing the number of needles
        num_trials: Number of trials for each needle count

    Returns:
        needle_counts: Array of needle counts used
        pi_estimates: Array of Pi estimates
        execution_times: Array of execution times
    """
    needle_counts = np.arange(step_size, max_needles + step_size, step_size)
    pi_estimates = np.zeros((len(needle_counts), num_trials))
    execution_times = np.zeros((len(needle_counts), num_trials))

    for i, n in enumerate(needle_counts):
        for j in range(num_trials):
            pi_est, _, _, exec_time = estimate_pi_buffon(n)
            pi_estimates[i, j] = pi_est
            execution_times[i, j] = exec_time

    return needle_counts, pi_estimates, execution_times

def plot_convergence(needle_counts, pi_estimates, save_path=None):
    """
    Plot the convergence of Pi estimates as the number of needles increases.

    Args:
        needle_counts: Array of needle counts used
        pi_estimates: Array of Pi estimates
        save_path: Path to save the figure (optional)
    """
    plt.figure(figsize=(12, 8))

    # Plot individual trials
    for j in range(pi_estimates.shape[1]):
        plt.plot(needle_counts, pi_estimates[:, j], 'o-', alpha=0.3, markersize=3)

    # Plot mean estimate
    mean_estimate = np.mean(pi_estimates, axis=1)
    plt.plot(needle_counts, mean_estimate, 'r-', linewidth=2, label='Mean Estimate')

    # Plot true value of Pi
    plt.axhline(y=np.pi, color='g', linestyle='--', label='True π')

    # Add error bands
    std_estimate = np.std(pi_estimates, axis=1)
    plt.fill_between(needle_counts, 
                     mean_estimate - std_estimate, 
                     mean_estimate + std_estimate, 
                     color='r', alpha=0.2, label='±1 Standard Deviation')

    plt.xscale('log')
    plt.grid(True, alpha=0.3)
    plt.xlabel('Number of Needles')
    plt.ylabel('Estimated π')
    plt.title('Convergence of Buffon\'s Needle π Estimation')
    plt.legend()

    if save_path:
        plt.savefig(save_path, dpi=300, bbox_inches='tight')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    # Example usage
    n_needles = 10000
    pi_estimate, crossings, n_needles, exec_time = estimate_pi_buffon(n_needles)
    print(f"Estimated π: {pi_estimate:.6f}")
    print(f"Crossings: {crossings}/{n_needles}")
    print(f"Execution time: {exec_time:.4f} seconds")

    # Visualize the method
    plot_buffon_needle(100, save_path="buffon_needle.png")

    # Analyze convergence
    needle_counts, pi_estimates, exec_times = convergence_analysis(100000, step_size=10000, num_trials=3)
    plot_convergence(needle_counts, pi_estimates, save_path="buffon_convergence.png")
</code></pre>
<p><img alt="Buffon's Needle Visualization" src="../buffon_needle.png"/></p>
<p><img alt="Buffon's Needle Convergence" src="../buffon_convergence.png"/></p>
<h2 id="3-comparison-of-methods">3. Comparison of Methods</h2>
<p>Both methods provide a way to estimate π using Monte Carlo techniques, but they have different characteristics:</p>
<h3 id="circle-method">Circle Method</h3>
<ul>
<li><strong>Advantages</strong>:</li>
<li>Simpler to implement</li>
<li>More intuitive visualization</li>
<li>Generally faster convergence</li>
<li>Less sensitive to numerical precision</li>
<li><strong>Disadvantages</strong>:</li>
<li>Requires more memory for large numbers of points</li>
<li>Less historically significant</li>
</ul>
<h3 id="buffons-needle-method">Buffon's Needle Method</h3>
<ul>
<li><strong>Advantages</strong>:</li>
<li>Historical significance (one of the first Monte Carlo methods)</li>
<li>Can be physically demonstrated</li>
<li>More interesting mathematical derivation</li>
<li><strong>Disadvantages</strong>:</li>
<li>Slower convergence</li>
<li>More sensitive to numerical precision</li>
<li>More complex implementation</li>
</ul>
<h3 id="convergence-comparison">Convergence Comparison</h3>
<p><img alt="Method Comparison" src="../method_comparison.png"/></p>
<p><img alt="Efficiency Comparison" src="../efficiency_comparison.png"/></p>
<h2 id="4-mathematical-analysis">4. Mathematical Analysis</h2>
<h3 id="circle-method_1">Circle Method</h3>
<p>The circle method is based on the ratio of areas:
- Circle area = πr²
- Square area = 4r²
- Ratio = π/4</p>
<p>Therefore, the probability of a random point falling inside the circle is π/4, and π = 4P.</p>
<h3 id="buffons-needle-method_1">Buffon's Needle Method</h3>
<p>Buffon's Needle is based on geometric probability:
- For a needle of length L and lines spaced a distance D apart
- The probability of a crossing is P = (2L)/(πD)
- Therefore, π = (2L)/(PD)</p>
<p>The derivation involves integrating over all possible positions and angles of the needle.</p>
<h2 id="5-conclusion">5. Conclusion</h2>
<p>Both Monte Carlo methods provide a way to estimate π using probabilistic techniques. While the circle method is generally more efficient and easier to implement, Buffon's Needle method has historical significance and provides an interesting physical demonstration of geometric probability.</p>
<p>The convergence analysis shows that both methods approach the true value of π as the number of trials increases, with the circle method generally converging faster. The efficiency comparison demonstrates the computational cost of each method as the number of trials increases.</p>
<p>These methods demonstrate how probabilistic techniques can be used to approximate deterministic mathematical constants, providing insight into the relationship between probability and geometry.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-left" href="../Problem_1/" title="Statistics"><span class="icon icon-circle-arrow-left"></span> Previous</a>
<a class="btn btn-neutral float-right" href="../../7%20Measurements/Problem_1/" title="Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span><a href="../Problem_1/" style="color: #fcfcfc">« Previous</a></span>
<span><a href="../../7%20Measurements/Problem_1/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="../../../js/jquery-3.6.0.min.js"></script>
<script>var base_url = "../../..";</script>
<script src="../../../js/theme_extra.js"></script>
<script src="../../../js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<script src="../../../search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
</body>
</html>
